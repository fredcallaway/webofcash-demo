// Generated by CoffeeScript 2.2.2
// coffeelint: disable=max_line_length, indentation
var BEST_VAL, BEST_VAL_WORD, BLOCKS, Block, CONDITION, DEBUG, DEMO, EXPERIMENT, LOCAL, N_TEST, N_TRAIN, N_TRAIN_REWARD, N_TRIAL, PARAMS, PASSED_INSTRUCT, PROLIFIC, SCORE, SELECTED_WATCH, SHOW, SKIP_BUTTON, STRUCTURE, TRIALS, WATCH_START, WATCH_TRIALS, calculateBonus, createStartButton, getSearchParam, getTrials, initializeExperiment, loadExperiment, makeParams, psiturk, saveData, searchParams;

getSearchParam = function(key) {
  var sp;
  sp = new URLSearchParams(location.search);
  return sp.get(key);
};

searchParams = new URLSearchParams(location.search);

SHOW = searchParams.get('show');

PROLIFIC = searchParams.get('hitId') === 'prolific';

DEBUG = SHOW === 'debug' || mode === "debug";

DEMO = mode === "demo";

LOCAL = mode === "{{ mode }}";

CONDITION = parseInt(condition);

if (isNaN(CONDITION)) {
  CONDITION = 6;
}

EXPERIMENT = parseInt(searchParams.get('exp'));

// if isNaN EXPERIMENT
//   EXPERIMENT = parseInt(prompt('Which experiment?'))
//   console.log EXPERIMENT
PASSED_INSTRUCT = false;

BLOCKS = void 0;

PARAMS = void 0;

TRIALS = void 0;

WATCH_TRIALS = void 0;

STRUCTURE = void 0;

N_TRIAL = void 0;

SELECTED_WATCH = void 0;

SKIP_BUTTON = DEBUG;

WATCH_START = parseInt(searchParams.get('trial') || "1") - 1;

SCORE = 0;

BEST_VAL = void 0;

BEST_VAL_WORD = void 0;

calculateBonus = void 0;

getTrials = void 0;

if (DEMO) {
  SKIP_BUTTON = false;
}

N_TRAIN = 3;

N_TRAIN_REWARD = 10;

N_TEST = 25;

psiturk = new PsiTurk(uniqueId, adServerLoc, mode);

saveData = function() {
  return new Promise(function(resolve, reject) {
    var timeout;
    if (DEMO || DEBUG) {
      resolve();
      return;
    }
    timeout = delay(10000, function() {
      return reject('timeout');
    });
    return psiturk.saveData({
      error: function() {
        clearTimeout(timeout);
        console.log('Error saving data!');
        return reject('error');
      },
      success: function() {
        clearTimeout(timeout);
        console.log('Data saved to psiturk server.');
        return resolve();
      }
    });
  });
};

$(window).resize(function() {
  return checkWindowSize(800, 680, $('#jspsych-target'));
});

$(window).resize();

$(window).on('load', function() {
  $(window).on('popstate', function() {
    return location.reload(true);
  });
  if (DEMO) {
    return runDemo();
  } else {
    return loadExperiment();
  }
});

makeParams = function() {
  var cb, fromSearch, params;
  cb = new ConditionBuilder(CONDITION);
  params = {
    inspectCost: 0,
    bonusRate: .005,
    clickDelay: 3000
  };
  // clickDelay: cb.choose [1000,2000,3000]
  _.extend(params, (function() {
    switch (EXPERIMENT) {
      case 1:
        return {
          variance: 'constant',
          branching: '412',
          expandOnly: true
        };
      case 2:
        return {
          variance: cb.choose(['decreasing', 'constant', 'increasing']),
          branching: '41111',
          expandOnly: true
        };
      case 3:
        return {
          variance: cb.choose(['decreasing', 'constant', 'increasing']),
          branching: '412',
          expandOnly: false
        };
    }
  })());
  fromSearch = mapObject(Object.fromEntries(searchParams), maybeJson);
  updateExisting(params, fromSearch);
  if (params.variance === 'constant') {
    BEST_VAL = "$10";
    BEST_VAL_WORD = "ten";
  } else {
    if (EXPERIMENT === 2) {
      BEST_VAL = "$20";
      BEST_VAL_WORD = "twenty";
    } else if (EXPERIMENT === 3) {
      BEST_VAL = "$18";
      BEST_VAL_WORD = "18";
    }
  }
  return params;
};

loadExperiment = function() {
  var loadTimeout, slowLoad;
  $('#load-icon').show();
  // Load data and test connection to server.
  slowLoad = function() {
    var ref;
    return (ref = $('slow-load')) != null ? ref.show() : void 0;
  };
  loadTimeout = delay(12000, slowLoad);
  psiturk.preloadImages(['static/images/spider.png']);
  return delay((DEBUG || LOCAL || DEMO ? 100 : 3000), function() {
    PARAMS = makeParams();
    psiturk.recordUnstructuredData('params', PARAMS);
    // psiturk.recordUnstructuredData 'startTime', String(new Date())
    STRUCTURE = loadJson(`static/json/structure/${PARAMS.branching}.json`);
    TRIALS = loadJson(`static/json/rewards/exp${EXPERIMENT}_${PARAMS.variance}.json`);
    console.log(`loaded ${(TRIALS != null ? TRIALS.length : void 0)} trials`);
    getTrials = (function() {
      var idx, t;
      t = _.shuffle(TRIALS);
      idx = 0;
      return function(n) {
        idx += n;
        return t.slice(idx - n, idx);
      };
    })();
    if (DEMO) {
      return initializeExperiment();
    }
    if (LOCAL) {
      createStartButton();
      return clearTimeout(loadTimeout);
    } else {
      return saveData().then(function() {
        $('#load-icon').hide();
        $('#slow-load').hide();
        clearTimeout(loadTimeout);
        return createStartButton();
      }).catch(function() {
        clearTimeout(loadTimeout);
        return $('#data-error').show();
      });
    }
  });
};


// $.get 'https://www.cloudflare.com/cdn-cgi/trace', (data) ->
//   psiturk.recordUnstructuredData 'trace', data
//   if LOCAL
//     clearTimeout loadTimeout
//     delay 500, createStartButton
//   else
//     saveData().then(->
//       clearTimeout loadTimeout
//       delay 500, createStartButton
//     ).catch(->
//       clearTimeout loadTimeout
//       $('#data-error').show()
//     )
createStartButton = function() {
  if (SKIP_BUTTON) {
    return initializeExperiment();
  } else {
    $('#success-load').show();
    return $('#load-btn').click(initializeExperiment);
  }
};

Block = class Block {
  constructor(config) {
    _.extend(this, config);
    this._block = this; // allows trial to access its containing block for tracking state
    if (this._init != null) {
      this._init();
    }
  }

};

initializeExperiment = function() {
  var ButtonBlock, MouselabBlock, QuizLoop, TextBlock, bonus_text, check_variance, completeHIT, correct_var, divider, experiment_timeline, fullMessage, img, manyHot, n_quiz, plain_divider, pre_test, prompt_resubmit, quiz, reprompt, reset_score, review_variance, save_data, skip, test, timeline, train_basic, train_final, train_hidden, train_inspector, train_intro, train_reward;
  $('#load-icon').hide();
  $('#slow-load').hide();
  $('#demo-landing').html("");
  psiturk.recordUnstructuredData('time_start', Date.now());
  $('#jspsych-target').html('');
  console.log('initialize experiment');
  TextBlock = (function() {
    //  ======================== #
    //  ========= TEXT ========= #
    //  ======================== #

    // These functions will be executed by the jspsych plugin that
    // they are passed to. String interpolation will use the values
    // of global variables defined in this file at the time the function
    // is called.

    // text =
    //   debug: -> if DEBUG then "`DEBUG`" else ''

    // ================================= #
    // ========= BLOCK CLASSES ========= #
    // ================================= #
    class TextBlock extends Block {};

    TextBlock.prototype.type = 'text';

    TextBlock.prototype.cont_key = [];

    return TextBlock;

  }).call(this);
  ButtonBlock = (function() {
    class ButtonBlock extends Block {};

    ButtonBlock.prototype.type = 'button-response';

    ButtonBlock.prototype.is_html = true;

    ButtonBlock.prototype.choices = ['Continue'];

    ButtonBlock.prototype.button_html = '<button class="btn btn-primary btn-lg">%choice%</button>';

    return ButtonBlock;

  }).call(this);
  QuizLoop = class QuizLoop extends Block {
    loop_function(data) {
      var c, j, len, ref;
      console.log('loop_function data', data);
      ref = data[data.length].correct;
      for (j = 0, len = ref.length; j < len; j++) {
        c = ref[j];
        if (!c) {
          alert("You got at least one question wrong. Please try again.");
          return true;
        }
      }
      return false;
    }

  };
  MouselabBlock = (function() {
    class MouselabBlock extends Block {
      _init() {
        _.extend(this, STRUCTURE);
        return this.trialCount = 0;
      }

    };

    MouselabBlock.prototype.type = 'mouselab-mdp';

    MouselabBlock.prototype.playerImage = 'static/images/spider.png';

    MouselabBlock.prototype.lowerMessage = 'Move with the arrow keys.';

    MouselabBlock.prototype.clickDelay = PARAMS.clickDelay;

    MouselabBlock.prototype.expandOnly = PARAMS.expandOnly;

    return MouselabBlock;

  }).call(this);
  //  ============================== #
  //  ========= EXPERIMENT ========= #
  //  ============================== #
  img = function(name) {
    return `<img class='display' src='static/images/${name}.png'/>`;
  };
  fullMessage = "";
  reset_score = new Block({
    type: 'call-function',
    func: function() {
      return SCORE = 0;
    }
  });
  divider = new TextBlock({
    text: function() {
      SCORE = 0;
      return "<div style='text-align: center; margin-top:100px'>Press <code>space</code> to continue.</div>";
    }
  });
  plain_divider = new TextBlock({
    text: function() {
      return "<div style='text-align: center; margin-top:100px'>Press <code>space</code> to continue.</div>";
    }
  });
  train_intro = new ButtonBlock({
    stimulus: markdown("## Instructions\n\nIn this experiment, you will play a game called *Web of Cash*, where you will\nhave a chance to earn a bonus by making smart decisions. But first,\nyou have to learn how to play!\n\n<div class=\"alert alert-warning\">\n<strong>Quiz Warning&nbsp;</strong>\n  There is a quiz at the end of the instructions. You will have only three tries\n  to complete it correctly; otherwise, you will not be allowed to complete the study\n  and will not earn a bonus. Please read all the instructions carefully!\n</div>")
  });
  train_basic = new MouselabBlock({
    blockName: 'train_basic',
    stateDisplay: 'always',
    prompt: function() {
      psiturk.finishInstructions(); // can't restart once you get here
      return markdown("## Web of Cash\n\nIn *Web of Cash*, you guide a money-loving spider through a spider web.\nWhen you land on a gray circle (a ***node***) the value of the node is\nadded to your score. Your final score determines your bonus\n(not counting these practice trials).\n\nYou can move the spider with the arrow keys, but only in the direction\nof the arrows between the nodes. Go ahead, try it out!");
    },
    timeline: getTrials(N_TRAIN)
  });
  train_reward = new MouselabBlock({
    blockName: 'train_reward',
    stateDisplay: 'always',
    exampleOnly: true,
    // lowerMessage: markdown 'Press `space` to continue.'
    timeline: [
      {
        examples: getTrials(N_TRAIN_REWARD)
      }
    ],
    prompt: function() {
      var diff, explain_variance, others;
      diff = "Some nodes are more important than others!";
      others = "All the other nodes are worth either 1 or -1.";
      explain_variance = (function() {
        switch (PARAMS.variance) {
          case 'decreasing':
            if (EXPERIMENT === 2) {
              return `${diff} The best and worst values (20 and -20) can only be found in the first four nodes of each path, right next to the spider. ${others}`;
            } else if (EXPERIMENT === 3) {
              return `${diff} The values are largest (-18 to 18) at the center of the web and smallest at the edges.`;
            }
            break;
          case 'increasing':
            if (EXPERIMENT === 2) {
              return `${diff} The best and worst values (20 and -40) can only be found in the last four nodes of each, furthest from the spider. ${others}`;
            } else if (EXPERIMENT === 3) {
              return `${diff} The values are largest (-18 to 18) at the edges of the web and smallest at the center.`;
            }
            break;
          case 'constant':
            return "Nodes can be worth -10, -5, 5, or 10. All of these are equally likely.";
          default:
            throw Error("bad variance");
        }
      })();
      return markdown(`## Node Values\n\n${explain_variance}\nOn average, none of the paths are better than any other path.\n\nHere are some examples of webs you might encounter.`);
    }
  });
  train_hidden = new MouselabBlock({
    blockName: 'train_hidden',
    stateDisplay: 'never',
    prompt: function() {
      return markdown("## Hidden Information\n\nWhen you can see the values of each node, it's not too hard to\ntake the best possible path. Unfortunately, you can't always see the\nvalue of the nodes. Without this information, it's hard to make good\ndecisions. Try completing another round.");
    },
    lowerMessage: 'Move with the arrow keys.',
    timeline: getTrials(1)
  });
  train_inspector = new MouselabBlock({
    blockName: 'train_inspector',
    lowerMessage: "Click on a node to inspect it's value.",
    special: 'trainClick',
    minClicks: 5,
    stateDisplay: 'click',
    stateClickCost: 0,
    prompt: function() {
      return markdown(`## Node Inspector\n\nIt's hard to make good decisions when you can't see what you're doing!\nFortunately, you have access to a ***node inspector*** which can reveal\nthe value of a node. To use the node inspector, simply click on a node.\n\n<div class="alert alert-info">\n  <strong>Note&nbsp;</strong>\n  You can use the node inspector as many times as you want. However, it\n  ${(PARAMS.expandOnly ? "has a limited range and " : "")}\n  takes some time to recharge. You can only inspect a node when it is\n  highlighted. Also, you cannot inspect any nodes after moving the spider.\n</div>`);
    },
    // but the node inspector takes some time to work and you can only inspect one node at a time.
    timeline: getTrials(N_TRAIN)
  });
  // lowerMessage: "<b>Click on the nodes to reveal their values.<b>"
  bonus_text = function(long, bold = true) {
    var make_bold, s;
    console.log("BONUS_TEXT", bold);
    make_bold = function(x) {
      if (bold) {
        return "**" + x + "**";
      } else {
        return x;
      }
    };
    switch (PARAMS.bonusRate) {
      case .01:
        s = make_bold("you will earn 1 cent for every $1 you make in the game.");
        if (long) {
          s += " For example, if your final score is $100, you will receive a bonus of $1.00";
        }
        return s;
      case .005:
        s = make_bold("you will earn 1 cent for every $2 you make in the game.");
        if (long) {
          s += " For example, if your final score is $200, you will receive a bonus of $1.00";
        }
        return s;
    }
  };
  train_final = new MouselabBlock({
    blockName: 'train_final',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    prompt: function() {
      return markdown(`## Earn a Big Bonus\n\nNice! You've learned how to play *Web of Cash*, and you're almost ready\nto play it for real. To make things more interesting, you will earn real\nmoney based on how well you play the game. Specifically,\n${bonus_text(true)} These are the final practice rounds before your score\nstarts counting towards your bonus.\n\n<div class="alert alert-info">\n<strong>Protip&nbsp;</strong>\n  You'll get the best wage from this study if you use the node inspector\n  enough to make good decisions, but not so much that you waste time.\n</div>`);
    },
    lowerMessage: fullMessage,
    timeline: getTrials(N_TRAIN)
  });
  review_variance = (function() {
    switch (PARAMS.variance) {
      case 'constant':
        return ', which could be anywhere in the web';
      case 'increasing':
        if (EXPERIMENT === 2) {
          return ", but only on the nodes at the end of each path";
        } else if (EXPERIMENT === 3) {
          return ", but only on the nodes at the edge of the web";
        }
        break;
      case 'decreasing':
        if (EXPERIMENT === 2) {
          return ", but only on the nodes at the beginning of each path";
        } else if (EXPERIMENT === 3) {
          return ", but only on the nodes at the center of the web";
        }
    }
  })();
  correct_var = (function() {
    switch (PARAMS.variance) {
      case 'constant':
        return 'Anywhere';
      case 'decreasing':
        return 'Only on the nodes closest to the spider';
      case 'increasing':
        return 'Only on the nodes furthest from the spider';
    }
  })();
  n_quiz = 0;
  quiz = new Block({
    preamble: function() {
      return markdown("# Quiz\n\nPlease answer the following questions before continuing.");
    },
    type: 'quiz',
    numTries: 3,
    onMistake: function() {
      n_quiz += 1;
      psiturk.recordUnstructuredData('n_quiz', n_quiz);
      return saveData();
    },
    questions: ["What is the best value a node can have?", "On which nodes might the best value appear?", "How many times can you use the node inspector on each round?", "How many points do you pay to use the node detector?"],
    // "What bonus will you earn if you end the game with $100?"
    options: [PARAMS.variance === 'constant' ? ['$1', '$5', '$10', '$20'] : ['$3', '$9', '$18', '$20'], ['Anywhere', 'Only on the top branch', 'Only on the left branch', 'Only on the nodes closest to the spider', 'Only on the nodes furthest from the spider'], ['One time', 'Three times', 'Five times', 'There is no limit'], ['None', '$1', '$2', '$3']],
    // ['$0.25', '$0.50', '$1.00', '$2.50']
    correct: [
      BEST_VAL,
      correct_var,
      'There is no limit',
      'None' // '$0.50'
    ],
    review: markdown(`In Web of Cash, you select routes through a spider web in order to make\nthe most money you can. Each location, or _node_, in the graph is worth\nsome amount of money, which you collect if you pass through that node on\nyour path. You can find up to ${BEST_VAL_WORD} dollars on a node${review_variance}.\nInitially the values of the nodes are hidden, but you can\nreveal them with the _node inspector_. On each round, you can use the\ninspector as many times as you like before you move the spider. There is\nno penalty for using the node inspector, but it does take time to\nrecharge. `)
  });
  // To make things more fun, you will earn real money (through your
  // bonus) based on how well you play: #{bonus_text(true, false)}
  manyHot = function(n, indices) {
    var i, j, len, x;
    x = Array(n).fill(false);
    for (j = 0, len = indices.length; j < len; j++) {
      i = indices[j];
      x[i] = true;
    }
    return x;
  };
  check_variance = new Block({
    conditional_function: function() {
      return PARAMS.variance !== 'constant';
    },
    timeline: [
      new MouselabBlock({
        blockName: 'comprehension',
        comprehension: true,
        selectNodes: (function() {
          switch (EXPERIMENT) {
            case 2:
              switch (PARAMS.variance) {
                case 'decreasing':
                  return manyHot(21,
      [1,
      6,
      11,
      16]);
                case 'increasing':
                  return manyHot(21,
      [5,
      10,
      15,
      20]);
              }
              break;
            case 3:
              switch (PARAMS.variance) {
                case 'decreasing':
                  return manyHot(17,
      [1,
      5,
      9,
      13]);
                case 'increasing':
                  return manyHot(17,
      [3,
      4,
      7,
      8,
      11,
      12,
      15,
      16]);
              }
          }
        })(),
        timeline: [
          {
            examples: getTrials(20)
          }
        ]
      })
    ]
  });
  pre_test = new ButtonBlock({
    stimulus: function() {
      SCORE = 100;
      PASSED_INSTRUCT = true;
      psiturk.recordUnstructuredData('time_instruct', Date.now());
      return markdown(`# Training Completed\n\nWell done! You've completed the training phase and you're ready to\nplay *Web of Cash* for real. You will have **${N_TEST}\nrounds** to make as much money as you can.<br>\nRemember, ${bonus_text()}\n\nTo thank you for your work so far, we'll start you off with **$100**.\nGood luck!`);
    }
  });
  test = new MouselabBlock({
    // minTime: 7
    blockName: 'test',
    lowerMessage: '',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    // timeline: [TRIALS[0]]
    timeline: getTrials(N_TEST),
    prompt: function() {
      return markdown(`# Test rounds\n\nYour current bonus is\n**$${calculateBonus().toFixed(2)}**`);
    }
  });
  // finish = new Block
  //   type: 'survey-text'
  //   preamble: -> markdown """
  //       # You've completed the experiment

  //       Thanks for participating. We hope you had fun! Based on your
  //       performance, you will be awarded a bonus of
  //       **$#{calculateBonus().toFixed(2)}**.

  //       Please briefly answer the questions below before you submit.
  //     """

  //   questions: [
  //     # 'What is your age?'
  //     'Can you briefly describe your strategy (one sentence)?'
  //     'Was anything confusing or hard to understand?'
  //     'Additional coments?'
  //   ]
  //   rows: 2
  //   button: 'Continue'
  timeline = [
    train_intro,
    train_basic,
    train_reward,
    train_hidden,
    train_inspector,
    train_final,
    quiz,
    // check_variance
    pre_test,
    test,
    plain_divider
  ];
  // finish
  skip = getSearchParam('skip');
  if (skip != null) {
    timeline = timeline.slice(skip);
  }
  // demo_timeline = () ->
  //   if SHOW == 'test'
  //     return [test]
  //   if SHOW == 'quiz'
  //     return [quiz, check_variance, pre_test, test]
  //   if SHOW == 'comprehension'
  //     return [check_variance, pre_test, test]
  //   if WATCH_TRIALS?
  //     return [watch]
  //   else
  //     return full_timeline

  // experiment_timeline = switch
  //   when DEBUG then debug_timeline
  //   when DEMO then demo_timeline()
  //   else full_timeline
  experiment_timeline = timeline;
  console.log('experiment_timeline', experiment_timeline, DEMO);
  // ================================================ #
  // ========= START AND END THE EXPERIMENT ========= #
  // ================================================ #
  completeHIT = function() {
    if (PROLIFIC) {
      $(window).off("beforeunload");
      return $('#prolific-complete').show();
    } else {
      return psiturk.completeHIT;
    }
  };
  // bonus is the total score multiplied by something
  calculateBonus = function() {
    var bonus;
    if (!PASSED_INSTRUCT) {
      return 0;
    }
    bonus = SCORE * PARAMS.bonusRate;
    bonus = (Math.round(bonus * 100)) / 100; // round to nearest cent
    return Math.max(0, bonus);
  };
  reprompt = null;
  save_data = function() {
    return psiturk.saveData({
      success: function() {
        $('#jspsych-target').html('');
        console.log('Data saved to psiturk server.');
        if (reprompt != null) {
          window.clearInterval(reprompt);
        }
        return psiturk.computeBonus('compute_bonus', completeHIT);
      },
      error: function() {
        return prompt_resubmit;
      }
    });
  };
  prompt_resubmit = function() {
    $('#jspsych-target').html("<h1>Oops!</h1>\n<p>\nSomething went wrong submitting your HIT.\nThis might happen if you lose your internet connection.\nPress the button to resubmit.\n</p>\n<button id=\"resubmit\">Resubmit</button>");
    return $('#resubmit').click(function() {
      $('#jspsych-target').html('Trying to resubmit...');
      reprompt = window.setTimeout(prompt_resubmit, 10000);
      return save_data();
    });
  };
  return jsPsych.init({
    display_element: $('#jspsych-target'),
    timeline: experiment_timeline,
    // show_progress_bar: true
    on_finish: function() {
      psiturk.recordUnstructuredData('time_end', Date.now());
      psiturk.recordUnstructuredData('final_bonus', calculateBonus());
      if (DEMO) {
        return jsPsych.data.displayData();
      } else {
        return save_data();
      }
    },
    on_data_update: function(data) {
      console.log('data', data);
      psiturk.recordTrialData(data);
      return saveData();
    }
  });
};
